//함수 목록
void InitializeGame();
void DrawEdge();
void DrawBricks();
void DrawPaddle();
void DrawBall();
void MovePaddle() ; 
void DrawPaddle();
void DrawBricks();
void GameOver();
void Minigame();
void StartBreak();
void ScoreCount();
SoftwareSerial mega_serial(MEGA_TX, MEGA_RX); 

enum button_types {
  NONE = 0,
  LEFT = 1,
  UP,
  RIGHT,
  DOWN,
  SELECT
};

RGBmatrixPanel matrix(A, B, C, D, CLK, LAT, OE, false, 64);
int matrix_colors[MAT_R][MAT_C];

// 게임 영역 크기
const int width = 64;
const int height = 32;

// 벽돌 상태
bool bricks[width][height];
int breaked_bricks[3] = {0,0,0};
int break_count = 0;
// 공의 현재 위치
int ballX = 32;
int ballY = 24;

// 공의 이동 방향
int ballSpeedX = 1;
int ballSpeedY = 1;

//패들의 현재 위치
int paddleX = 32;
int paddleY = 31;

//패들의 이동방향
int paddleSpeedX = -1;

//점수 상태
int Breakscore = 0;

//게임 상태
bool Breakgame = true ;

// 랜덤으로 특별한 벽돌 선택
int specialBrickX = 1 + random(62) ;
int specialBrickY = 1 + random(10) ;

// 초기화 함수
void InitializeGame() {
  // 벽돌 초기화
  for (int i = 2; i < width - 2; i++) {
    for (int j = 2; j < height - 18; j++) {
      bricks[i][j] = true;
    }
  }
  for (int i = 2; i < width - 2; i++) {
    for (int j = height - 18; j < height; j++) {
      bricks[i][j] = false;
    }
}
for (int i = 1; i < height; i++) {
  bricks[0][i] = false ;
  bricks[63][i] = false ;
  bricks[1][i] = false ;
  bricks[62][i] = false ;
}
for (int i = 0; i < width; i++) {
  bricks[i][0] = false ;
  bricks[i][1] = false ;
}
}
// 공을 움직이는 함수
void MoveBall() {
  // 현재 위치에서 공을 지웁니다.
  bool is_paddle;
  bool is_side;
  bool is_ceil;
  bool is_floor;
  matrix.drawPixel(ballX, ballY, matrix.Color333(0, 0, 0));

  // 새로운 위치로 공을 이동합니다.
  ballX += ballSpeedX;
  ballY += ballSpeedY;
  Serial.print("ball : ");
  Serial.print(ballX);
  Serial.print(",");
  Serial.print(ballY);
  Serial.println();

  is_paddle = (ballY + 1 == paddleY) && (ballX >= paddleX-1 && ballX <= paddleX + 2);
  is_floor = (ballY >= height - EDGE);
  is_ceil = (ballY <= EDGE);
  is_side = (ballX <= EDGE) || (ballX >= width - EDGE - 1);

  if (is_floor) {
    game = false;
    return;
  }
  if (is_paddle) {
    ballSpeedY = -ballSpeedY;
    ballSpeedX = -ballSpeedX;
    return;
  }
  // 벽에 부딪혔다면 방향을 변경합니다.
  if (is_side) {
    ballSpeedX = -ballSpeedX;
  }
  if (is_ceil) {
    ballSpeedY = -ballSpeedY;
  }

// 벽돌과의 충돌 검사
  if (bricks[ballX+ballSpeedX][ballY]) {
    if( ballX != 1 && ballX != 62 && ballY != 1) {
    matrix.drawPixel(ballX+ballSpeedX, ballY, matrix.Color333(0, 0, 0));
    }
    ballSpeedX = -ballSpeedX ;
    PlaySoundEffect(4,true);
  }
  if (bricks[ballX][ballY+ballSpeedY]) {
    if( ballX != 1 && ballX != 62 && ballY != 1) {
    matrix.drawPixel(ballX, ballY+ballSpeedY, matrix.Color333(0, 0, 0));
    }    
    ballSpeedY = -ballSpeedY ;
    PlaySoundEffect(4,true);
  }
  else if (bricks[ballX+ballSpeedX][ballY] == false && bricks[ballX+ballSpeedX][ballY+ballSpeedY]) {
    if( ballX != 1 && ballX != 62 && ballY != 1) {
    matrix.drawPixel(ballX+ballSpeedX, ballY+ballSpeedY, matrix.Color333(0, 0, 0));
    }
    ballSpeedY = -ballSpeedY ;
    ballSpeedX = -ballSpeedX ;
    PlaySoundEffect(4,true);
  }
  if ( ballY + 1 == paddleY ) {
    if ( paddleX - 1 < ballX && ballX < paddleX + 4) {
    ballSpeedY = -ballSpeedY ;
  }
}


// 벽돌 그리기 함수
void DrawBricks() {
  for (int i=2;i<14;i++) {
    matrix.drawLine(2,i,61,i,matrix.Color333(0,0,7));
}
  if (bricks[specialBrickX][specialBrickY]) {
    matrix.drawPixel(specialBrickX, specialBrickY, matrix.Color333(3, 5, 3)); //특별한 벽돌 색상변경
  }
}


//공 그리는 함수 
void DrawBall() { 
  matrix.drawPixel(ballX, ballY, matrix.Color333(7, 7, 7));
}

//패들 그리는 함수
void DrawPaddle() {
    matrix.drawLine(paddleX-1, paddleY, paddleX+2, paddleY,  matrix.Color333(2, 7, 7));
}
//패들 움직이는 함수
void MovePaddle() {
  int btn = ProcessInputButton1();
  if ( paddleX != EDGE && btn == LEFT) {
    Serial.println("left");
    matrix.drawLine(paddleX-1, paddleY, paddleX+2, paddleY,  matrix.Color333(0, 0, 0));
    paddleX+=paddleSpeedX;
  }
  else if ( paddleX != MAT_C-EDGE-1 && btn == RIGHT) {
    Serial.println("right");
    matrix.drawLine(paddleX-1, paddleY, paddleX+2, paddleY,  matrix.Color333(0, 0, 0));
    paddleX-=paddleSpeedX;
  }
 }

//모서리 벽 그리기 함수
void drawEdge() {
  matrix.drawLine(0,0,0,31,matrix.Color333(0,0,7));
  matrix.drawLine(1,0,62,0,matrix.Color333(0,0,7));
  matrix.drawLine(63,0,63,31,matrix.Color333(0,0,7));
  matrix.drawLine(0,0,0,30,matrix.Color333(0,0,7));
  matrix.drawLine(1,0,61,0,matrix.Color333(0,0,7));
  matrix.drawLine(62,0,62,31,matrix.Color333(0,0,7));
}

//점수 계산 함수
void ScoreCount() {
  for (int i = 1; i < width - 1; i++) {
    for (int j = 1; j < height - 19; j++) {
      if (bricks[i][j] == false) {
        Breakscore++;
      }
    }
  }
}

//게임오버 출력 함수
void GameOver() {
  matrix.fillScreen(0); 
  matrix.setCursor(5, 32/ 2 - 4); 
  matrix.print("GAME OVER");
  delay(5000);
}

//미니게임 함수
void Minigame() {
  matrix.fillScreen(0);
}

//벽돌깨기 게임 실행
void StartBreak() {
  unsigned int prev_ball_move = 0;
  unsigned int cur_ball_move = 0;
  unsigned int prev_paddle_move = 0;
  unsigned int cur_paddle_move = 0;

  ballX = 32;
  ballY = 24;

  // 공의 이동 방향
  ballSpeedX = 1;
  ballSpeedY = 1;

  //패들의 현재 위치
  paddleX = 32;
  paddleY = 31;

  //패들의 이동방향
  paddleSpeedX = -1;

  //점수 상태
  Breakscore = 0;

  //게임 상태
  Breakgame = true ;
  InitializeGame();
  DrawEdge();
  DrawBricks();
//PlayBackGroundMusicMP3(); 음악 정해서 ()안에 넣기
  DrawBall();
  DrawPaddle();
  Drawbricks();
//텍스트 세팅
  matrix.setTextSize(1);
  matrix.setTextColor(matrix.Color333(7, 7, 7));
  while (true) {
    cur_ball_move = millis();
    if(cur_ball_move - prev_ball_move >= BALL_DELAY){
      MoveBall();
      DrawBall();
      prev_ball_move = cur_ball_move;
    }
    cur_paddle_move = millis();
    if(cur_paddle_move - prev_paddle_move >= PADDLE_DELAY){
      Serial.print("paddle : ");
      Serial.println(paddleX);
      MovePaddle();
      DrawPaddle(); 
      prev_paddle_move = cur_paddle_move;
    }
    if (!Breakgame) {
      GameOver();
      matrix.fillScreen(0);
      break ;
    }
  }
}
  

// 초기 설정 함수
void setup() {
//통신 세팅
  Serial.begin(9600);
  mega_serial.begin(BAUD_RATE);
//매트릭스 세팅
  matrix.begin(); // RGB 매트릭스 초기화
  matrix.setTextSize(1);
  matrix.setTextColor(matrix.Color333(7, 7, 7)); 

}

// 메인 루프 함수
void loop() {
   StartBreak() ;
}
